// =============================================================================
// Module 5-A: Deduplication Guard
// =============================================================================
// Prevents infinite sync loops by tracking every sync operation with a UUID.
//
//   1. registerSyncId   — Store a sync UUID in memory + SyncDedupeLog
//   2. isSyncEcho       — Check whether a sync UUID was generated by us
//   3. extractSyncId    — Pull the sync UUID out of webhook / contact data
//
// In-memory set: LRUCache (max 1 000 entries, 5-minute TTL).
// Persistent:    SyncDedupeLog MongoDB collection (5-minute TTL index).
//
// Flow:
//   Outgoing write → registerSyncId(uuid)
//     ↓ webhook echoes back
//   Incoming webhook → extractSyncId(payload) → isSyncEcho(uuid)
//     → true  ⇒ skip
//     → false ⇒ process
// =============================================================================
import crypto from 'crypto';
import SyncDedupeLog from '../models/SyncDedupeLog';
import { LRUCache } from '../utils/lruCache';
import logger from '../utils/logger';

// ─────────────────────────────────────────────────────────────────────────────
// In-memory set — max 1 000 entries, 5-minute TTL
// ─────────────────────────────────────────────────────────────────────────────

/** Value is `true`; the cache is used as a Set<syncId>. */
const recentSyncIds = new LRUCache<string, true>(1_000, 5 * 60 * 1000);

/** Expiry duration for DB records (5 minutes). */
const EXPIRY_MS = 5 * 60 * 1000;

// ─────────────────────────────────────────────────────────────────────────────
// 1. Generate + register a sync ID
// ─────────────────────────────────────────────────────────────────────────────

/**
 * Generates a UUID v4 sync ID (or accepts a pre-generated one) and
 * records it in both the in-memory cache and the SyncDedupeLog collection.
 *
 * Call this **every time** we write a contact to Wix or HubSpot so that
 * the resulting webhook echo can be recognised and suppressed.
 *
 * @param instanceId — Wix site instance
 * @param side       — Which platform we are writing to ('wix' | 'hubspot')
 * @param contactId  — Contact ID on the written-to side
 * @param syncId     — Optional pre-generated UUID (one is created if omitted)
 * @returns          — The sync ID (pass it to `writeSyncTag` / SyncMetadata)
 */
export async function registerSyncId(
  instanceId: string,
  side: 'wix' | 'hubspot',
  contactId: string,
  syncId?: string,
): Promise<string> {
  const id = syncId ?? crypto.randomUUID();

  // Memory first — this is the fast path for isSyncEcho
  recentSyncIds.set(id, true);

  // Persist to DB (non-blocking — fire-and-forget with error logging)
  SyncDedupeLog.create({
    syncId: id,
    instanceId,
    side,
    contactId,
    expiresAt: new Date(Date.now() + EXPIRY_MS),
  }).catch((err) => {
    logger.warn('Failed to persist SyncDedupeLog entry', {
      syncId: id,
      instanceId,
      error: (err as Error).message,
    });
  });

  return id;
}

// ─────────────────────────────────────────────────────────────────────────────
// 2. Check whether a sync ID is one of ours
// ─────────────────────────────────────────────────────────────────────────────

/**
 * Returns `true` if the given sync ID was generated by our own write —
 * meaning the webhook that carries it is an echo that should be skipped.
 *
 * Checks the in-memory cache first (O(1)).  On a cache miss, falls back
 * to a MongoDB query.
 *
 * @param syncId — The UUID extracted from the incoming webhook / contact
 */
export async function isSyncEcho(syncId: string | undefined): Promise<boolean> {
  if (!syncId) return false;

  // Fast path — memory
  if (recentSyncIds.get(syncId)) {
    logger.debug('Dedupe hit (memory)', { syncId: syncId.slice(0, 8) });
    return true;
  }

  // Slow path — DB
  try {
    const record = await SyncDedupeLog.findOne({ syncId }).lean();
    if (record) {
      // Promote back into memory for subsequent checks
      recentSyncIds.set(syncId, true);
      logger.debug('Dedupe hit (DB)', { syncId: syncId.slice(0, 8) });
      return true;
    }
  } catch (err) {
    // On DB error, fail open — better to process a duplicate than to
    // silently drop a genuine change
    logger.warn('SyncDedupeLog lookup failed, failing open', {
      syncId: syncId.slice(0, 8),
      error: (err as Error).message,
    });
  }

  return false;
}

// ─────────────────────────────────────────────────────────────────────────────
// 3. Extract sync ID from webhook / contact data
// ─────────────────────────────────────────────────────────────────────────────

/**
 * Pulls the sync ID from an incoming webhook payload or contact record.
 *
 * — **HubSpot side**: looks for `wix_sync_tag` in the contact properties.
 * — **Wix side**: looks for `custom.wix_sync_tag` in extended fields, or
 *   falls back to `info.extendedFields.items.custom.wix_sync_tag.value`.
 *
 * @param data — Webhook payload or contact object
 * @param side — Which platform sent the webhook
 */
export function extractSyncId(
  data: Record<string, any>,
  side: 'wix' | 'hubspot',
): string | undefined {
  if (side === 'hubspot') {
    // HubSpot contact properties
    return (
      data?.properties?.wix_sync_tag ??
      data?.wix_sync_tag ??
      undefined
    );
  }

  // Wix contact extended fields
  const extFields = data?.info?.extendedFields?.items ?? data?.extendedFields ?? {};
  return (
    extFields?.['custom.wix_sync_tag']?.value ??
    extFields?.['custom.wix_sync_tag'] ??
    data?.['custom.wix_sync_tag'] ??
    undefined
  );
}

// ─────────────────────────────────────────────────────────────────────────────
// Utilities (exposed for testing / admin)
// ─────────────────────────────────────────────────────────────────────────────

/** Clear the in-memory sync-ID set. */
export function clearMemoryCache(): void {
  recentSyncIds.clear();
}

/** Number of sync IDs currently held in memory. */
export function memoryCacheSize(): number {
  return recentSyncIds.size;
}
